# useReducer
## reducer: 상태를 실제로 변화시키는 변환기 역할
- 컴포넌트 내부에 새로운 State를 생성하는 리엑트 훅
- 모든 useState는 useReducer로 대체 가능
- useState와는 달리 상태 관리 코드를 컴포넌트 외부로 분리할 수 있음
- 상태변화가 있다라는 사실을 알리는 발송 함수

> const [state, dispatch] = useReducer(reducer,0);
- dispatch가 호출되면 상태변화가 요청되고, useReducer가 상태변화를 실제로 처리하는 함수를 요청
 → 실제로 만들어야 함

### reducer 함수 선언
! react-review 참고
- 컴포넌트 밖에서 reducer 처리에 대한 함수 작성
    ```jsx
    function reducer(state, action){
        console.log(state,action); //action 객체는 increase, data
        if(){
        }else if(){
        }
    }
    ```
- 컴포넌트 작성
    ```jsx
    const Reducer = () => {
        const [state, dispatch] = useReducer(reducer,0);
                                        //    함수명, 초기값
        return(
            <div>
                <h1>0</h1>
                <button onClick={onPlus}>+</button> {/*버튼을 누르면 dispatch함수에 상태 변화 요청*/}
                <button onClick={onMinus}>-</button>
            </div>
        )
    }
    ```
- 값을 더하는 onPlus 함수 작성
    ```jsx
    const Reducer = () => {
        const onPlus =() =>{
            dispatch({
                type:"increase", //값 증가 요청
                data: 1,
            }) //상태변화 요청
        }
    }
    ```
- 값을 빼는 onMinus 함수 작성
    ```jsx
    const Reducer = () => {
        const onMinus = () =>{
            dispatch({
                type:"decrease", //값 증가 요청
                data: 1,
            }) 
        }
    }
    ```
- reducer에서 상태에 따른 처리
    ```jsx
    function reducer(state, action){
        console.log(state,action); //action 객체는 increase, data
        if(action.type==="increase"){
            return state + action.data;
        }else if(action.type==="decrease"){
            return state - action.data;
        }
    }
    ```

# 최적화 - useMemo
- "메모리제이션" 기법을 기반으로 불필요한 연산을 최적화하는 리액트 훅
- 동일한 연산을 할 때 결과값을 메모리에 저장해두고 있다가 필요할 때 결과값을 돌려줌

<br>
<br>
<hr>
<hr>

# To Do List를 Reducer로 변경
## App.jsx에서 useState로 작성된 함수들을 reducer로 변경
! todolist-reducer 참고
### dispatch 상태에 따라 반환할 함수 작성
- 컴포넌트 바깥에 작성, switch-case문 활용
    ```jsx
    function reducer(state, action) {
    switch (action.type) {
        case 'create':
        return [action.data, ...state]; // 새로운 값, 원래 값

        case 'update':
        return state.map((item) =>
            item.id === action.targetId ? { ...item, idDo: !item.idDo } : item
        );

        case 'delete':
        return state.filter((todo) => todo.id !== action.targetId);

        default:
        return state;
    }
    }
    ```
### 함수 변경
- 컴포넌트에 useState대신 useReducer 값을 활용하도록 변경
    ```jsx
    const [todos, dispatch] = useReducer(reducer, copyData);
    ```
- onUpdate함수 변경
    ```jsx
    const onUpdate = (targetId) => {
        dispatch({
        type: 'update',
        targetId: targetId,
        });
    };
    ```
- onDelete함수 변경
    ```jsx
    const onDelete = (targetId) => {
        dispatch({
        type: 'delete',
        targetId: targetId,
        });
    };
    ```
- onCreate함수 변경
    ```jsx
    const onCreate = (content) => {
        dispatch({
        type: 'create',
        data: {
            id: idState.current++,
            idDo: false,
            content: content,
            date: new Date().getTime(),
        },
        });
    };
    ```
# useMemo를 활용하여 List.jsx 변경
## 할 일 추가 시 개수를 count하는 함수 작성
- 컴포넌트 내부에 함수 작성
    ```jsx
    const analyze = () =>{
        const total=todos.length; //전체 todolist 개수(3개)
        const doCnt=todos.filter( //할일 개수
            (todo) => todo.idDo).length;

        const notDo = total-doCnt; //하지 않은일 개수

        return{
            total,
            doCnt,
            notDo
        }
    }
    const {total, doCnt, notDo} = analyze();
    ```
- 화면에 출력되도록 return에 추가
    ```jsx
    <div>
        <div>total: {total}</div>
        <div>doCnt: {doCnt}</div>
        <div>notDo: {notDo}</div>
    </div>
    ```

## useMemo를 활용하도록 수정
- useMemo로 바로 함수 작성하므로 analyze함수를 바로 호출하도록 변경
- 콜백함수 형태: 콜백함수가 반환하는 값을 그대로 반환해줌 → deps를 기준으로 메모리제이션함
- 빈 배열로 설정했으므로 첫번째 콜백함수의 연산반환이 컴포넌트가 최초로 렌더링 되었을 때 한번만 이루어짐
    > useMemo로 만들면 연산은 딱 한번만 수행!
```jsx
    const {total, doCnt, notDo} = useMemo(()=>{
        const total=todos.length; //전체 todolist 개수(3개)
        const doCnt=todos.filter( //할일 개수
            (todo) => todo.idDo).length;

        const notDo = total-doCnt; //하지 않은일 개수

        return{
            total,
            doCnt,
            notDo
        }
    },[]); 
```

- 작성화면: ![](/07.%20리엑트/00.%20img/06-1.png)